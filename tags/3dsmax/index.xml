<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>3dsmax on PEPETD</title>
    <link>https://felipenogueira3d.com/tags/3dsmax/index.xml</link>
    <description>Recent content in 3dsmax on PEPETD</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2017 by felipenogueira3d.com</copyright>
    <atom:link href="https://felipenogueira3d.com/tags/3dsmax/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Find Verts Weighted to Bone Function</title>
      <link>https://felipenogueira3d.com/posts/find-verts-weighted-to-bone-function/</link>
      <pubDate>Mon, 23 Mar 2015 12:31:28 -0700</pubDate>
      
      <guid>https://felipenogueira3d.com/posts/find-verts-weighted-to-bone-function/</guid>
      <description>&lt;p&gt;Here is a little function I wrote that will go through all selected meshes and find all the vertices weighted to a given bone. I had to write this to find all the meshes that had a specific bone in their skin mod, but not just that! I needed to know which of those meshes had verts weighted to this specific bone.&lt;/p&gt;

&lt;p&gt;The main task was to remove the influence of that bone from all meshes not necessarily remove the bone as the engine export strips out any bone that has no vertices weighted to it.&lt;/p&gt;

&lt;p&gt;There are also ways to get the influenced verts of selected bone by hand, but I needed a way to go through hundreds to thousands of meshes in a timely manner.&lt;/p&gt;

&lt;iframe src=&#34;https://player.vimeo.com/video/60972226&#34; width=&#34;640&#34; height=&#34;400&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
fn findWeightedVertsFn theBone =
(
    max modify mode
    clearListener()
    theAr = selection as array
    for obj in theAr do
    (
        select obj
        skinMods = getclassinstances Skin target:obj
        for s = 1 to skinMods.count where skinMods.count &gt; 0 do
        (
            skel = skinOps.getnumberbones skinMods[s]
            verts = skinOps.getNumberVertices skinMods[s]
            for x = 1 to skel do
            (
                If (skinOps.getBoneName skinMods[s] x 0) == theBone do
                (
                    skinOps.selectBone skinMods[s] x
                    skinOps.selectVerticesByBone skinMods[s]

                    selectedVerts = #()
                    for v = 1 to verts do
                    (
                        theVert = skinOps.IsVertexSelected skinMods[s] v
                        if theVert == 1 do append selectedVerts v
                    )

                    if selectedVerts.count &gt; 0 do
                    (
                        print (obj.name + &#34; has &#34; + (selectedVerts.count as string) + &#34; verts weighted to &#34; + theBone)
                    )
                )
            )
        )
    )
    clearselection()
)

/*
findWeightedVertsFn &#34;The Bone Name&#34;
*/
</description>
    </item>
    
    <item>
      <title>Constraint Functions - 3DS Max</title>
      <link>https://felipenogueira3d.com/posts/constraint-functions---3ds-max/</link>
      <pubDate>Sun, 22 Mar 2015 12:28:09 -0700</pubDate>
      
      <guid>https://felipenogueira3d.com/posts/constraint-functions---3ds-max/</guid>
      <description>&lt;p&gt;In the past years I started creating my own library of functions and scripts that would automate a lot of the processes that I often use when rigging characters to speed up the rigging process even more.&lt;/p&gt;

&lt;p&gt;I have so many rigging functions that one day I realized I could create an entire humanoid rig in a matter of minutes by using all these functions as long as I had a skeleton created.&lt;/p&gt;

&lt;p&gt;In time I will be releasing a function library for all of you to check it out, meanwhile, here is a little preview of some of the functions I use often, the Look-At constraint could use more work but the Position Constraint, Orientation Constraint and Path Constraint Functions are perfect for pretty much anything that I would use them for.&lt;/p&gt;
-- Position Constraint
-- PosConst (Affected Node) (Target Node) (Target Weight)
-- (newCon:true if fresh constrain, false if adding target to existing constrain)
fn PosConst obj target tarWeight newCon:true =
(
    if newCon == true then
    (
        Pc = Position_Constraint()
        obj.pos.controller.available.controller = Pc
        posConstraint = Pc.constraints
        posConstraint.appendtarget target tarWeight
    )
    else
    (
        obj.position.controller.Position_Constraint.appendtarget target tarWeight
    )
    obj.pos.controller.setactive 3
)

-- Look-At Constraint
-- LookConst (Affected Node) (Target Node) (upNode:UpNode Node) (Target Weight)
-- (newCon:true if fresh constrain, false if adding target to existing constrain)
fn LookConst obj target upNode tarWeight newCon:true =
(
    if newCon == true then
    (
        Lc = LookAt_Constraint()
        obj.rotation.controller.available.controller = Lc
        locConstraint = Lc.constraints
        locConstraint.appendtarget target tarWeight
        Lc.upnode_world = false
        Lc.pickUpNode = upNode
        Lc.lookat_vector_length = 0
    )
    else
    (
        obj.rotation.controller.LookAt_Constraint.appendtarget target tarWeight
    )
    obj.rotation.controller.setactive 3
)

-- Orientation Constraint
-- OrientConst (Affected Node) (Target Node) (Target Weight) (keepOff: keep off-set True or False)
-- (newCon:true if fresh constrain, false if adding target to existing constrain)
fn OrientConst obj target tarWeight keepOff:false newCon:true =
(
    if newCon == true then
    (
        Oc = Orientation_Constraint()
        obj.rotation.controller.available.controller = Oc
        orientConstraint = Oc.constraints
        orientConstraint.appendtarget target tarWeight
        Oc.relative = keepOff
    )
    else
    (
        obj.rotation.controller.Orientation_Constraint.appendtarget target tarWeight
    )
    obj.rotation.controller.setactive 3
)

-- Path Constraint
-- PathConst (Affected Node) (Target Node) (Target weight) (Percent on path)
fn PathConst obj target tarWeight percent =
(
    Pc = Path_Constraint()
    obj.pos.controller.available.controller = Pc
    Pc.path = target
    deletekeys obj
    Pc.follow = true
    Pc.percent = percent
    obj.pos.controller.setactive 3
)


-- Freeze Transform -- Function created by Mathieson Facer.
-- FreezeTransform (Obj to Freeze)
fn FreezeTransform Obj =
(
    local curObj = Obj
    if classof CurObj.rotation.controller != Rotation_Layer do
    (
        -- freeze rotation
        curObj.rotation.controller = Euler_Xyz()
        curObj.rotation.controller = Rotation_list()
        curObj.rotation.controller.available.controller = Euler_xyz()

        /* &#34;Localization on&#34; */
        CurObj.rotation.controller.setname 1 &#34;Frozen Rotation&#34;
        CurObj.rotation.controller.setname 2 &#34;Zero Euler XYZ&#34;

        /* &#34;Localization off&#34; */
        CurObj.rotation.controller.SetActive 2
    )

    if classof CurObj.position.controller != Position_Layer do
    (
        -- freeze position
        CurObj.position.controller = Bezier_Position()
        CurObj.position.controller = position_list()
        CurObj.position.controller.available.controller = Position_XYZ()

        /* &#34;Localization on&#34; */
        CurObj.position.controller.setname 1 &#34;Frozen Position&#34;
        CurObj.position.controller.setname 2 &#34;Zero Pos XYZ&#34;

        /* &#34;Localization off&#34; */
        CurObj.position.controller.SetActive 2

        -- position to zero
        CurObj.Position.controller[2].x_Position = 0
        CurObj.Position.controller[2].y_Position = 0
        CurObj.Position.controller[2].z_Position = 0
    )
)
</description>
    </item>
    
    <item>
      <title>The Future of 3DS Max</title>
      <link>https://felipenogueira3d.com/posts/the-future-of-3ds-max/</link>
      <pubDate>Mon, 09 Sep 2013 12:26:26 -0700</pubDate>
      
      <guid>https://felipenogueira3d.com/posts/the-future-of-3ds-max/</guid>
      <description>&lt;p&gt;Read the &lt;a href=&#34;http://www.maxunderground.com/archives/19385_autodesk_siggraph_event_news___including_future_of_naiad.html&#34;&gt;comments section&lt;/a&gt; of this post on Max Underground.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>