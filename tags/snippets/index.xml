<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Snippets on PEPETD</title>
    <link>http://felipenogueira3d.com/tags/snippets/index.xml</link>
    <description>Recent content in Snippets on PEPETD</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2017 by felipenogueira3d.com</copyright>
    <atom:link href="http://felipenogueira3d.com/tags/snippets/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Parent Constraint to Last - Maya Python</title>
      <link>http://felipenogueira3d.com/posts/parent-constraint-to-last---maya-python/</link>
      <pubDate>Mon, 23 Mar 2015 12:34:20 -0700</pubDate>
      
      <guid>http://felipenogueira3d.com/posts/parent-constraint-to-last---maya-python/</guid>
      <description>&lt;p&gt;Snippet to constraint all selected nodes to the last selected.&lt;/p&gt;
import maya.cmds as cmds
nodes = cmds.ls(sl=True)
myParent = grps[-1]
grps.pop()
for node in nodes:
    cmds.parentConstraint(parent, myParent, mo=True, weight=1) ## mo = False if you do not want to maintain offset
</description>
    </item>
    
    <item>
      <title>Create FK Chain - Maya Python</title>
      <link>http://felipenogueira3d.com/posts/create-fk-chain---maya-python/</link>
      <pubDate>Mon, 23 Mar 2015 12:29:30 -0700</pubDate>
      
      <guid>http://felipenogueira3d.com/posts/create-fk-chain---maya-python/</guid>
      <description>&lt;p&gt;Hey guys! first rigging script for python in maya! pretty simple, it creates a FK chain from selected joints with flags to align the controllers to world or to the Joint. Wrote this script to do Gainer&amp;rsquo;s(Sasktel) spine rig in Maya ( I am re-rigging him in Maya.)&lt;/p&gt;
# ------------------------------------------------------------------------------------------------------
# Rigging Modules
# -- Method Rigger (Maya)
#
# By: Felipe[PePeTD]Nogueira
# ------------------------------------------------------------------------------------------------------

## Imports
import maya
import maya.cmds as cmds

# Create FK Chain rig Module.
# createFKChain(world) - if left unchanged, world = True by default.
# -------------------------------------------------------------------
def createFKChain(world=True):
    ## Grab current selection (!warning this function works on any type of node).
    joints = cmds.ls(sl=True)
    locators = []
    circles = []
    groups = []
    counter = 0

    ## Goes through the newly created list of joints and creates a locator and controller
    ## for each node grouping and constrainning it all accordinly.
    for joint in joints:
        curPos = cmds.xform(joint, q=True, ws=True, t=True)

        ## Creates the locator at the position of the node, Centers its pivot, and freezes it.
        curLoc = cmds.spaceLocator(p=curPos)
        locators.append(curLoc)
        cmds.CenterPivot(curLoc)
        cmds.parent(curLoc, joint)
        cmds.makeIdentity(curLoc, apply=True, t=1, r=1, s=1)

        ## Creates the Circle shape at the position of the node and aligns it to the node depending
        ## on the state of (world) if true then aligns it to world if false the circle shapes will be
        ## aligned to the node(joint).

        ## Align the control curves to world or to each given node according to the state of (world).
        if world == True:
            curCircle = cmds.circle(nr=[0, 0, 1], r=1, c=curPos)
            circles.append(curCircle)
            cmds.CenterPivot(curCircle)
            cmds.makeIdentity(curCircle, apply=True, t=1, r=1, s=1)
            curGroup = cmds.duplicate(curCircle[0], rr=True, rc=True, po=True)
            curGroup[0] = cmds.rename(curGroup[0], (curGroup[0]+&#34;_Grp&#34;))
            groups.append(curGroup)
            cmds.parent(curCircle[0], curGroup[0])
        else:
            curCircle = cmds.circle(nr=[1, 0, 0], r=1)
            circles.append(curCircle)
            cmds.parent(curCircle[0], joint)
            cmds.CenterPivot(curCircle)
            cmds.makeIdentity(curCircle, apply=False, t=1, r=1, s=1)
            cmds.parent(curCircle[0], w=True)
            curGroup = cmds.duplicate(curCircle[0], rr=True, rc=True, po=True)
            curGroup[0] = cmds.rename(curGroup[0], (curGroup[0]+&#34;_Grp&#34;))
            groups.append(curGroup)
            cmds.parent(curCircle[0], curGroup[0])

        ## Checks to see if we are on the first node or not and does the appropriate tasks.
        if counter == 0:
            cmds.parent(curLoc[0], w=True)
            rigGroup = cmds.duplicate(curLoc[0], rr=True, rc=True, po=True)
            rigGroup[0] = cmds.rename(rigGroup[0], (rigGroup[0]+&#34;_Grp&#34;))
            cmds.parent(joint, rigGroup[0])
            cmds.parent(curLoc[0], rigGroup[0])
        else:
            cmds.parent(curLoc[0], locators[counter-1][0])
            cmds.parent(curGroup[0], circles[counter-1][0])

        ## Finally we parentContraint the joint to the locator.
        cmds.parentConstraint(curCircle[0], curLoc[0], mo=True)
        cmds.parentConstraint(curLoc[0], joint, mo=True)

        counter += 1

createFKChain(world=False)
## END.
</description>
    </item>
    
    <item>
      <title>Constraint Functions - 3DS Max</title>
      <link>http://felipenogueira3d.com/posts/constraint-functions---3ds-max/</link>
      <pubDate>Sun, 22 Mar 2015 12:28:09 -0700</pubDate>
      
      <guid>http://felipenogueira3d.com/posts/constraint-functions---3ds-max/</guid>
      <description>&lt;p&gt;In the past years I started creating my own library of functions and scripts that would automate a lot of the processes that I often use when rigging characters to speed up the rigging process even more.&lt;/p&gt;

&lt;p&gt;I have so many rigging functions that one day I realized I could create an entire humanoid rig in a matter of minutes by using all these functions as long as I had a skeleton created.&lt;/p&gt;

&lt;p&gt;In time I will be releasing a function library for all of you to check it out, meanwhile, here is a little preview of some of the functions I use often, the Look-At constraint could use more work but the Position Constraint, Orientation Constraint and Path Constraint Functions are perfect for pretty much anything that I would use them for.&lt;/p&gt;
-- Position Constraint
-- PosConst (Affected Node) (Target Node) (Target Weight)
-- (newCon:true if fresh constrain, false if adding target to existing constrain)
fn PosConst obj target tarWeight newCon:true =
(
    if newCon == true then
    (
        Pc = Position_Constraint()
        obj.pos.controller.available.controller = Pc
        posConstraint = Pc.constraints
        posConstraint.appendtarget target tarWeight
    )
    else
    (
        obj.position.controller.Position_Constraint.appendtarget target tarWeight
    )
    obj.pos.controller.setactive 3
)

-- Look-At Constraint
-- LookConst (Affected Node) (Target Node) (upNode:UpNode Node) (Target Weight)
-- (newCon:true if fresh constrain, false if adding target to existing constrain)
fn LookConst obj target upNode tarWeight newCon:true =
(
    if newCon == true then
    (
        Lc = LookAt_Constraint()
        obj.rotation.controller.available.controller = Lc
        locConstraint = Lc.constraints
        locConstraint.appendtarget target tarWeight
        Lc.upnode_world = false
        Lc.pickUpNode = upNode
        Lc.lookat_vector_length = 0
    )
    else
    (
        obj.rotation.controller.LookAt_Constraint.appendtarget target tarWeight
    )
    obj.rotation.controller.setactive 3
)

-- Orientation Constraint
-- OrientConst (Affected Node) (Target Node) (Target Weight) (keepOff: keep off-set True or False)
-- (newCon:true if fresh constrain, false if adding target to existing constrain)
fn OrientConst obj target tarWeight keepOff:false newCon:true =
(
    if newCon == true then
    (
        Oc = Orientation_Constraint()
        obj.rotation.controller.available.controller = Oc
        orientConstraint = Oc.constraints
        orientConstraint.appendtarget target tarWeight
        Oc.relative = keepOff
    )
    else
    (
        obj.rotation.controller.Orientation_Constraint.appendtarget target tarWeight
    )
    obj.rotation.controller.setactive 3
)

-- Path Constraint
-- PathConst (Affected Node) (Target Node) (Target weight) (Percent on path)
fn PathConst obj target tarWeight percent =
(
    Pc = Path_Constraint()
    obj.pos.controller.available.controller = Pc
    Pc.path = target
    deletekeys obj
    Pc.follow = true
    Pc.percent = percent
    obj.pos.controller.setactive 3
)


-- Freeze Transform -- Function created by Mathieson Facer.
-- FreezeTransform (Obj to Freeze)
fn FreezeTransform Obj =
(
    local curObj = Obj
    if classof CurObj.rotation.controller != Rotation_Layer do
    (
        -- freeze rotation
        curObj.rotation.controller = Euler_Xyz()
        curObj.rotation.controller = Rotation_list()
        curObj.rotation.controller.available.controller = Euler_xyz()

        /* &#34;Localization on&#34; */
        CurObj.rotation.controller.setname 1 &#34;Frozen Rotation&#34;
        CurObj.rotation.controller.setname 2 &#34;Zero Euler XYZ&#34;

        /* &#34;Localization off&#34; */
        CurObj.rotation.controller.SetActive 2
    )

    if classof CurObj.position.controller != Position_Layer do
    (
        -- freeze position
        CurObj.position.controller = Bezier_Position()
        CurObj.position.controller = position_list()
        CurObj.position.controller.available.controller = Position_XYZ()

        /* &#34;Localization on&#34; */
        CurObj.position.controller.setname 1 &#34;Frozen Position&#34;
        CurObj.position.controller.setname 2 &#34;Zero Pos XYZ&#34;

        /* &#34;Localization off&#34; */
        CurObj.position.controller.SetActive 2

        -- position to zero
        CurObj.Position.controller[2].x_Position = 0
        CurObj.Position.controller[2].y_Position = 0
        CurObj.Position.controller[2].z_Position = 0
    )
)
</description>
    </item>
    
  </channel>
</rss>